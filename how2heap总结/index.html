<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Q1IQ"><title>how2heap总结 · Q1IQ</title><meta name="description" content="本文是自己的一点心得，没有特别地总结整理。
编译找了半天编译的方法，结果突然发现文件夹里有个Makefile，一键make就全编译了，我觉得我就是个憨憨。
first_fitchar* a = malloc(512); 经过对齐后 chunk size 为 0x210
free(a);后块a被放到 "><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Q1IQ</a></h3><div class="description"><p>北京邮电大学 网络空间安全专业</p></div></div></div><ul class="social-links"></ul><script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="footer"><a target="_blank" href="/"><span id="busuanzi_container_site_pv"></span><i class="fa fa-eye"></i>访问量<span id="busuanzi_value_site_pv"></span>次 |  <span id="busuanzi_container_site_uv"></span><i class="fa fa-user-md"></i>访客数<span id="busuanzi_value_site_uv"></span>人</a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>how2heap总结</a></h3></div><div class="post-content"><p>本文是自己的一点心得，没有特别地总结整理。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>找了半天编译的方法，结果突然发现文件夹里有个Makefile，一键make就全编译了，我觉得我就是个<code>憨憨</code>。</p>
<h3 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h3><p><code>char* a = malloc(512);</code> 经过对齐后 chunk size 为 0x210</p>
<p><code>free(a);</code>后块a被放到 unsorted_bins 中</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwODE1MTYxMzUxLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>执行 <code>c = malloc(500);</code> （500+8）经过16字节对齐后 chunk size 为 0x200 ，此时small bins是空的，就从unsorted bins中找，找到了大小为0x210的块a。而0x210 的块切割后剩下的块大小为0x10，小于MINSIZE（0x20），所以不切直接分配。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwODE1MTYxNTU2LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>然后自己测试了一下</p>
<ol>
<li><p><code>c = malloc(512-0x20+8);</code>需要的 chunk size 为 0x190 ，对齐后还是0x190，切割后留下的0x20就放在unsorted bins里了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwODE1MTY0MTUyLnBuZw?x-oss-process=image/format,png" alt=""></p>
</li>
<li><p><code>c = malloc(512-0x20+9);</code> 对齐后为 0x200 ，就不切了。</p>
</li>
</ol>
<h3 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h3><p>fastbin，double free<br>fastbin free的时候只检查了和bin相连的块和当前free的块地址相不相同</p>
<h3 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h3><p>在栈里构造一个块，使得该块的size满足可更改fd的chunk所在的bin的idx，就可将该伪造的块放入该bin，得以分配。<br>fd改为其他的值会报错<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwODE4MTY1MDQ1LnBuZw?x-oss-process=image/format,png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*d = (unsigned long long) (((char*)(&amp;stack_var)) - 8);</span><br></pre></td></tr></table></figure>

<p>报错是因为</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwOTAzMTUxNDI2LnBuZw?x-oss-process=image/format,png" alt=""></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwOTAzMTUxOTEyLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>也就是说分配的时候会根据块size计算 idx ，并和块所在 fastbin 的 idx 进行比较，如果不对就报错</p>
<p>试着在data段分配一个堆块</p>
<p><img src="https://img-blog.csdnimg.cn/20190929212507323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM1MDg4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9xaWlxLTEyNTg4ODc2MjUuY29zLmFwLWNoZW5nZHUubXlxY2xvdWQuY29tLzIwMTkwOTAzMTUzOTQyLnBuZw?x-oss-process=image/format,png" alt=""></p>
<p>| <a href="glibc_2.25/fastbin_dup_into_stack.c">fastbin_dup_into_stack.c</a> | Tricking malloc into returning a nearly-arbitrary pointer by abusing the fastbin freelist. | latest | <a href="https://github.com/ctfs/write-ups-2015/tree/master/9447-ctf-2015/exploitation/search-engine" target="_blank" rel="noopener">9447-search-engine</a>, <a href="http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html" target="_blank" rel="noopener">0ctf 2017-babyheap</a> |</p>
<h3 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h3><p><code>malloc_consolidate</code>这个函数的作用就是将fastbin合并后置入unsorted bin，一般调用的情况有以下几种：</p>
<pre><code>1. malloc的大小在smallbin范围内，若对应的smallbin没初始化的时候。
2. malloc的size大于small bin的范围，先调用malloc_consolidate将fastbin 合并为unsorted bin（本例的情况，再free一次，就可以在fastbin和unsortedbin中拥有同一个块）
3. top chunk不够空间
4. free某chunk时，该chunk合并前后空闲块后的大小超过了fastbin的收缩阈值（FASTBIN_CONSOLIDATION_THRESHOLD 也就是65536 0x10000）。(一般与top合并时会触发)</code></pre><p>同时有下面两点需要注意的:</p>
<pre><code>1. malloc_consolidate在合并fastbin的过程中没有对其size进行校验（House of Rabbit）
2. malloc_consolidate将合并后生成的chunk插入到unsorted bin头部</code></pre><p>参考资料：<a href="https://ch4r1l3.github.io/2019/01/22/malloc-consolidate调用条件/" target="_blank" rel="noopener">https://ch4r1l3.github.io/2019/01/22/malloc-consolidate调用条件/</a></p>
<p> <a href="glibc_2.25/fastbin_dup_consolidate.c">fastbin_dup_consolidate.c</a> | Tricking malloc into returning an already-allocated heap pointer by putting a pointer on both fastbin freelist and unsorted bin freelist. | latest | <a href="https://github.com/mehQQ/public_writeup/tree/master/hitcon2016/SleepyHolder" target="_blank" rel="noopener">Hitcon 2016 SleepyHolder</a> |</p>
<h3 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h3><p>看 ctfwiki<br>| <a href="glibc_2.26/unsafe_unlink.c">unsafe_unlink.c</a> | Exploiting free on a corrupted chunk to get arbitrary write. | &lt; 2.26 | <a href="http://acez.re/ctf-writeup-hitcon-ctf-2014-stkof-or-modern-heap-overflow/" target="_blank" rel="noopener">HITCON CTF 2014-stkof</a>, <a href="https://gist.github.com/niklasb/074428333b817d2ecb63f7926074427a" target="_blank" rel="noopener">Insomni’hack 2017-Wheel of Robots</a> |</p>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h3><p>先初始化内存<code>malloc(1);</code><br>不可控内存的前后内存可控的话，构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 块的size在fastbin范围内</span><br><span class="line">2. nextchunk的size </span><br><span class="line">&gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena)</span><br><span class="line">没找到system_mem在哪，亲测0x21000-8可，0x21000不可</span><br><span class="line">3. The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;)</span><br></pre></td></tr></table></figure>
<p>free该块即可将当前块放入fastbin。</p>
<p>| <a href="glibc_2.25/house_of_spirit.c">house_of_spirit.c</a> | Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer. | latest | <a href="https://github.com/ctfs/write-ups-2014/tree/master/hack-lu-ctf-2014/oreo" target="_blank" rel="noopener">hack.lu CTF 2014-OREO</a> |</p>
<h3 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison_null_byte"></a>poison_null_byte</h3><p>需要构造的点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P是size被null的块，Q是P的nextchunk</span><br><span class="line">1. chunksize(P) == prev_size (next_chunk(P)) 这个size是offbyone后的size，next_chunk是根据P的size算的，prev_size (next_chunk(P)) 可以自己伪造为offbyone后的size（因为offbyone后的size一定&lt;=原始size）</span><br><span class="line">2.分割P为块A和B</span><br><span class="line">3.free A，free Q，A和Q会 consolidate， B就被overlap了</span><br><span class="line">	free的时候</span><br><span class="line">	- 检查前一个chunk空闲吗（检查本块的prev_inuse）</span><br><span class="line">	- 检查后一个是不是top chunk</span><br><span class="line">	- 检查后一个chunk空闲吗（nextinuse = inuse_bit_at_offset(nextchunk, nextsize);）</span><br></pre></td></tr></table></figure>
<p>利用的点就在于free Q的时候，没有检查 prev_size(Q) == chunksize（pre_chunk(Q)）<br>glibc2.23检查还没那么严格，不检查chunksize( p ) != prevsize)<br><img src="https://img-blog.csdnimg.cn/20191015193932305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM1MDg4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.29是要检查的了（我看的在线版是2.29而已），这个利用方法就失效了。<br><img src="https://img-blog.csdnimg.cn/20191015182545197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzM1MDg4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>| <a href="glibc_2.25/poison_null_byte.c">poison_null_byte.c</a> | Exploiting a single null byte overflow. | &lt; 2.26 | <a href="https://github.com/ctfs/write-ups-2015/tree/master/plaidctf-2015/pwnable/plaiddb" target="_blank" rel="noopener">PlaidCTF 2015-plaiddb</a> |</p>
<h3 id="house-of-lore-small-bin"><a href="#house-of-lore-small-bin" class="headerlink" title="house_of_lore(small bin)"></a>house_of_lore(small bin)</h3><p>可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。<br>具体看ctfwiki吧<br>| <a href="glibc_2.26/house_of_lore.c">house_of_lore.c</a> | Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist. | &lt; 2.26 | |</p>
<h3 id="overlapping-chunks（更改块大小）"><a href="#overlapping-chunks（更改块大小）" class="headerlink" title="overlapping_chunks（更改块大小）"></a>overlapping_chunks（更改块大小）</h3><p>A|B|C<br>A的size改为A+B的size<br>free(A)<br>malloc(sizeof(A+B)) 即可overlap B<br>| <a href="glibc_2.26/overlapping_chunks.c">overlapping_chunks.c</a> | Exploit the overwrite of a freed chunk size in the unsorted bin in order to make a new allocation overlap with an existing chunk | &lt; 2.26 | <a href="https://github.com/ctfs/write-ups-2015/tree/master/hack-lu-ctf-2015/exploiting/bookstore" target="_blank" rel="noopener">hack.lu CTF 2015-bookstore</a>, <a href="https://github.com/ctfs/write-ups-2016/tree/master/nuitduhack-quals-2016/exploit-me/night-deamonic-heap-400" target="_blank" rel="noopener">Nuit du Hack 2016-night-deamonic-heap</a> |</p>
<h3 id="overlapping-chunks-2（向高地址合并）"><a href="#overlapping-chunks-2（向高地址合并）" class="headerlink" title="overlapping_chunks_2（向高地址合并）"></a>overlapping_chunks_2（向高地址合并）</h3><p>不考虑和top合并， 块均非fastbin<br>A|B|C<br>A的size改为A+B的size<br>free( C )<br>free( A )<br>malloc(A+B+C)<br>B就被overlap了<br>| <a href="glibc_2.25/overlapping_chunks_2.c">overlapping_chunks_2.c</a> | Exploit the overwrite of an in use chunk size in order to make a new allocation overlap with an existing chunk  | latest | |</p>
<h3 id="house-of-force-top-chunk"><a href="#house-of-force-top-chunk" class="headerlink" title="house_of_force(top chunk)"></a>house_of_force(top chunk)</h3><p>前提：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能够以溢出等方式控制到 top chunk 的 size 域</span><br><span class="line">能够自由地控制堆分配尺寸的大小</span><br></pre></td></tr></table></figure>
<p>例子中把top chunk的size设为-1    (0xffffffff)，然后<code>malloc(需控制的地址-0x10-top的地址-0x8)</code>：例子中需控制的地址在bss段上（heap低地址处），因此malloc的是个负数。top被分配后指向了需控制的地址-0x10的位置，然后再从top里分配一次就可以任意地址写了。<br>| <a href="glibc_2.25/house_of_force.c">house_of_force.c</a> | Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer | &lt; 2.29 | <a href="https://github.com/ctfs/write-ups-2016/tree/master/boston-key-party-2016/pwn/cookbook-6" target="_blank" rel="noopener">Boston Key Party 2016-cookbook</a>, <a href="https://github.com/ctfs/write-ups-2016/tree/master/bctf-2016/exploit/bcloud-200" target="_blank" rel="noopener">BCTF 2016-bcloud</a> |</p>
<h3 id="unsorted-bin-into-stack"><a href="#unsorted-bin-into-stack" class="headerlink" title="unsorted_bin_into_stack"></a>unsorted_bin_into_stack</h3><p>构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. free块a（size为y）到unsortd bin，修改a-&gt;bk为栈中地址 stack_buffer</span><br><span class="line">2. 构造栈中块的size z、构造bk里存放的是一个可写的地址（比较苛刻，很难找到这两者同时满足的块）</span><br><span class="line"> 	stack_buffer[1] = 0x100 + 0x10;</span><br><span class="line">  stack_buffer[3] = (intptr_t)(stack_buffer+10);</span><br><span class="line">3. malloc(z)即可在栈中的块任意写。</span><br></pre></td></tr></table></figure>
<p>| <a href="glibc_2.26/unsorted_bin_into_stack.c">unsorted_bin_into_stack.c</a> | Exploiting the overwrite of a freed chunk on unsorted bin freelist to return a nearly-arbitrary pointer.  | &lt; 2.26 | |</p>
<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted_bin_attack"></a>unsorted_bin_attack</h3><p>把要取出的unsorted chunk的bk改为[global_max_fast]-0x10，就可以将一个很大的值（unsorted bin的头地址 ）写到global_max_fast。</p>
<ul>
<li>覆盖了chunk的fd也没关系，因为根本没用上</li>
<li>改了之后unsorted bin头的bk指向了[global_max_fast]-0x10，再插入 chunk 时，可能会出现问题，但这时候块都变成fastbin了，所以一般也没啥问题（我觉得）</li>
<li>没有<code>bck-&gt;fd != victim</code>检查才行</li>
</ul>
<p>| <a href="glibc_2.26/unsorted_bin_attack.c">unsorted_bin_attack.c</a> | Exploiting the overwrite of a freed chunk on unsorted bin freelist to write a large value into arbitrary address  | &lt; 2.26 | <a href="https://github.com/ctfs/write-ups-2016/tree/master/0ctf-2016/exploit/zerostorage-6" target="_blank" rel="noopener">0ctf 2016-zerostorage</a> |</p>
<h3 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h3><p>构造</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 一个 large bin chunk 可以实现两个地址内容的修改。将 bk 和 bk_nextsize 改为某两个地址，这两个地址会被写入同一个堆地址。</span><br><span class="line">p是一个 large bin chunk 的地址</span><br><span class="line">	p2[0] = 0;//fd</span><br><span class="line">	p2[1] = (unsigned long)(&amp;stack_var2 - 2);//2表示2*8</span><br><span class="line">    p2[2] = 0;//fd_nextsize</span><br><span class="line">    p2[3] = (unsigned long)(&amp;stack_var4 - 4);</span><br><span class="line">2. 从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面（比构造过的chunk大），新来的chunk的地址就是被写入的堆地址。</span><br></pre></td></tr></table></figure>
<p>| <a href="glibc_2.26/large_bin_attack.c">large_bin_attack.c</a> | Exploiting the overwrite of a freed chunk on large bin freelist to write a large value into arbitrary address  | &lt; 2.26 | <a href="https://dangokyo.me/2018/04/07/0ctf-2018-pwn-heapstorm2-write-up/" target="_blank" rel="noopener">0ctf 2018-heapstorm2</a> |</p>
<h3 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house_of_einherjar"></a>house_of_einherjar</h3><p>前提是有一个offbyone漏洞。</p>
<p>后向合并的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">           prevsize = prev_size(p);</span><br><span class="line">           size += prevsize;</span><br><span class="line">           p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">           unlink(av, p, bck, fwd);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>构造这个块关键在于通过unlink检查：（P是伪造的将被consolidate的低地址的块，P|Q，Q被nullbyte）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 利用 unlink 漏洞的时候：</span><br><span class="line">p-&gt;fd = &amp;p-3*4</span><br><span class="line">p-&gt;bk = &amp;p-2*4</span><br><span class="line">在这里利用时，因为没有办法找到 &amp;p , 所以直接让：</span><br><span class="line">p-&gt;fd = p</span><br><span class="line">p-&gt;bk = p</span><br><span class="line">2. chunksize(P) != prev_size (next_chunk(P)） next_chunk是根据P的size算的，也就是说只要P偏移size处的值为size即可。</span><br><span class="line">3. Q的PREINUSE位为0，prev_size（Q）需覆盖到P的头部，free（Q）即可获得P+Q的空闲chunk</span><br></pre></td></tr></table></figure>
<p>和poison_null_byte的区别在于，<br>4. 向低地址合并的时候，house_of_einherjar低地址的块是自己伪造的，而poison_null_byte低地址的块是free来的<br>5. 对于P|Q，poison_null_byte是P被nullbyte，而且是先free P，再nullbyte，所以保留了pre_size(Q)，nullbyte后构造假的pre_size(nextchunk( P ))，free Q即可获得P+Q，例子里还把P给分成了A|B（因为P的size已经被nullbyte了，所以怎么分都不会再影响pre_size(Q)），然后free A（不free也行，但为了通过size和unlink检查，就得构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(size_t*)(b1+0x100) = 0x110;//chunksize( A ) != prev_size (next_chunk( A )）</span><br><span class="line">*(size_t*)(b1) = (size_t*)(b1-0x10);//FD-&gt;bk != P || BK-&gt;fd != P</span><br><span class="line">*(size_t*)(b1+0x8) =(size_t*) (b1-0x10);</span><br></pre></td></tr></table></figure>
<p>），free Q后就能够overlap B，这样做的原因是更灵活，因为能控制B的所有信息；house_of_einherjar是Q被nullbyte，然后在P中构造一个假的freed的chunk（p-&gt;fd = p p-&gt;bk = p；chunksize( P ) != prev_size (next_chunk( P )），prev_size（Q）需恰好覆盖到假chunk的头部，free（Q）即可获得 <code>假chunk+Q</code>的空闲chunk。</p>
<p>以上是比较保守的做法，how2heap里的就相对大胆，在栈里伪造一个假的freed的chunk，把prev_size（Q）改为<code>nullbyte了的块的地址-栈中假chunk的地址</code>，free（Q）获得了在栈上malloc块的机会。<br>| <a href="glibc_2.26/house_of_einherjar.c">house_of_einherjar.c</a> | Exploiting a single null byte overflow to trick malloc into returning a controlled pointer  | &lt; 2.26 | <a href="https://gist.github.com/hhc0null/4424a2a19a60c7f44e543e32190aaabf" target="_blank" rel="noopener">Seccon 2016-tinypad</a> |</p>
<h3 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house_of_orange"></a>house_of_orange</h3><p>在题目没有free的情况下，通过malloc(大于top chunk size的值)以将top放入unsortedbin中来获得一个freed的chunk。<br>how2heap的16.04可跑，18.04跑不起来，看的ctfwiki，和IOFILE结合的部分还没怎么看懂<br>| <a href="glibc_2.25/house_of_orange.c">house_of_orange.c</a> | Exploiting the Top Chunk (Wilderness) in order to gain arbitrary code execution  | &lt; 2.26 | <a href="https://github.com/ctfs/write-ups-2016/tree/master/hitcon-ctf-2016/pwn/house-of-orange-500" target="_blank" rel="noopener">Hitcon 2016 houseoforange</a> |</p>
<h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><p>前提条件: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 可以修改 fastbin 的 fd 指针或 size </span><br><span class="line">2. 可以触发 malloc consolidate(merge top 或 malloc big chunk 等等)</span><br></pre></td></tr></table></figure>
<p>效果：把块放入修改后的size对应的small bin里</p>
<h3 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h3><p>fastbin attack 和 Unsortbin attack 结合的一个小 trick。<br>fastbin attack用于在malloc hook附近分配堆块<br>Unsortbin attack用于在malloc hook处填上unsorted bin header的address</p>
<h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h3><p>tcache的doublefree，看起来什么都没检查（能放进tcache即可），只要有一个地址可以free两次就可。<br>| <a href="glibc_2.26/tcache_dup.c">tcache_dup.c</a> | Tricking malloc into returning an already-allocated heap pointer by abusing the tcache freelist. | 2.26 - 2.28 | |</p>
<h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h3><p>只要改掉放进了tcache的块的fd，就可以获取任意地址的内存</p>
<ul>
<li>和fastbin attack的区别在于分配时 tcache 不和块所在 bin 的 idx 进行比较</li>
</ul>
<p>| <a href="glibc_2.26/tcache_poisoning.c">tcache_poisoning.c</a> | Tricking malloc into returning a completely arbitrary pointer by abusing the tcache freelist. | &gt; 2.25  | |</p>
<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h3><p>得先初始化内存malloc(1);<br>需构造chuck的size &lt;=0x410即在tcache范围内<br> The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n”);</p>
<ul>
<li>和fastbin attack的区别在于nextchunk的size 需要合法，tcache没这个要求</li>
</ul>
<p>| <a href="glibc_2.26/tcache_house_of_spirit.c">tcache_house_of_spirit.c</a> | Frees a fake chunk to get malloc to return a nearly-arbitrary pointer. | &gt; 2.25 | |</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-10-29</span><i class="fa fa-tag"></i><a class="tag" href="/tags/学习/" title="学习">学习 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://q1iq.top/how2heap总结/,Q1IQ,how2heap总结,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/%E6%B9%96%E6%B9%98%E6%9D%AF-wp/" title="湖湘杯 wp">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-ichunqiu-wp/" title="巅峰极客 ichunqiu wp">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":true,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":200,"height":400,"hOffset":400,"vOffset":0},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>